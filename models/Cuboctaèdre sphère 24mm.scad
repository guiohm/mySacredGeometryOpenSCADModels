version = 4;
arete = 12;
paroi = 1.2;
trou_bouchon = 0;
diametreTrouBouchon = 1.5;
bottomHole = 0;
bottomHoleDiameter = 1.2;
vertexHole = 1;
vertexHolesDiameter = 1;
sideHole = 0;
sideHolesDiameter = 1.2;

dihedralAngle = 125.264;

// distance entre la paroi extérieure et la découpe
// minimum semble etre >nozzle_diameter pour Zortrax M200
offset_decoupe_bouchon = 0.42;

echelleReductionAjustementBouchon = 0.94;
r = 0.19; // résolution d'impression sur l'axe Z
Cpi = 3.14159;
Cphi = (1+sqrt(5))/2;
Cepsilon = 0.00000001;


function int_radius(a) =
    a*cos(45);

function arete_from(int_radius) =
    int_radius/cos(45);

externalRadius = arete;
internalRadius = arete_from(int_radius(arete)-paroi);

echo(internalRadius);

render(convexity=2)
//forme_creuse();
//decoupe_bouchon();
corps_ouvert();
// bouchon();
//trou();

module corps_ouvert() {
  // rotation pour face triangle
  // rotate([180 - dihedralAngle, 0, 0])
  // rotate([0, 0, 45])
  difference() {
    forme_creuse();
    decoupe_bouchon();
    if (bottomHole) {
      translate([0, 0, -externalRadius+1])
      #cylinder(paroi*3, r=bottomHoleDiameter/2, $fn=22);
    }
    if (sideHole) {
      rotate([0, 0, 45])
      rotate([180 - dihedralAngle, 0, 0])
      translate([0, 0, externalRadius*.6])
      #cylinder(paroi*3, r=bottomHoleDiameter/2, $fn=22);
    }
    if (vertexHole) {
      trou_pointe();
    }
  }
}

module bouchon() {
  rotate([-90, 45, 0])
  scale([echelleReductionAjustementBouchon, echelleReductionAjustementBouchon, 0.98])
  difference () {
    intersection() {
        // forme_creuse();
        decoupe_bouchon(echelleReductionAjustementBouchon);
    }
    if (vertexHole) {
      trou_pointe();
    } else if (trou_bouchon) {
      trou();
    }
  }
}

module trou() {
    rotate([0, 0, 0])
    translate([0, 0, externalRadius*0.5])
    cylinder(30, r=diametreTrouBouchon/2, $fn=22);
}

module trou_pointe() {
    rotate([90, 0, 45])
    translate([0, 0, externalRadius*.7])
    #cylinder(paroi*3, r=bottomHoleDiameter/2, $fn=22);
}

module forme_creuse() {
  difference() {
    cuboctahedron(externalRadius);
    cuboctahedron(internalRadius);
  }
}

module decoupe_bouchon(scale=1) {
  distance = int_radius(arete)-paroi/2;
  d = arete-offset_decoupe_bouchon;
  rotate([0,0,45]) translate([0,0, distance])
    cube([d, d, paroi], center=true);
  // rotate([0,0,0]) translate([0,0, distance-paroi])
  //   cylinder(paroi, r=(arete-paroi)*0.66, $fn=4, center=true);
}



module cuboctahedron(radius) {

  // Cuboctahedron

  // base coordinates
  // source:  http://dmccooey.com/polyhedra/Cuboctahedron.txt
  // generated by  http://kitwallace.co.uk/3d/solid-to-scad.xq
  Name = "Cuboctahedron";
  // 4 sided faces = 6
  // 3 sided faces = 8
  C0 = 0.7071067811865475244008443621048;
  points = [
  [ C0, 0.0,  C0],
  [ C0, 0.0, -C0],
  [-C0, 0.0,  C0],
  [-C0, 0.0, -C0],
  [ C0,  C0, 0.0],
  [ C0, -C0, 0.0],
  [-C0,  C0, 0.0],
  [-C0, -C0, 0.0],
  [0.0,  C0,  C0],
  [0.0,  C0, -C0],
  [0.0, -C0,  C0],
  [0.0, -C0, -C0]];
  faces = [
  [  4 ,  1,  5,  0],
  [ 10 ,  2,  8,  0],
  [  3 ,  6,  2,  7],
  [ 10 ,  5, 11,  7],
  [  3 , 11,  1,  9],
  [  4 ,  8,  6,  9],
  [  8 ,  4,  0],
  [ 11 ,  5,  1],
  [ 10 ,  7,  2],
  [  9 ,  6,  3],
  [  9 ,  1,  4],
  [ 10 ,  0,  5],
  [  8 ,  2,  6],
  [ 11 ,  3,  7]];
  edges = [
  [1,4],
  [1,5],
  [0,5],
  [0,4],
  [2,10],
  [2,8],
  [0,8],
  [0,10],
  [3,6],
  [2,6],
  [2,7],
  [3,7],
  [5,10],
  [5,11],
  [7,11],
  [7,10],
  [3,11],
  [1,11],
  [1,9],
  [3,9],
  [4,8],
  [6,8],
  [6,9],
  [4,9]];
  // ---------------------------------


  // cut holes out of shell
  eps=0.02;
  //radius=12;
  shell_ratio=0.1;
  prism_base_ratio =0.8;
  prism_height_ratio=0.3;
  prism_scale=0.5;
  nfaces = [];
  scale=1;

  //insert

  spoints = normalize(centre_points(points),radius);
  sfaces = lhs_faces(faces,spoints);
  cfaces =  select_nsided_faces(sfaces,nfaces);

  module shape() {
    difference() {
      polyhedron(spoints,sfaces);
      scale(1-shell_ratio) polyhedron(spoints,sfaces);
      face_prisms_in(cfaces,spoints,prism_base_ratio,prism_scale,prism_height_ratio);
    }
  }

  scale(scale)
    translate([0, 0, -int_radius(radius)])
      place_on_largest_face(sfaces,spoints)
  //    shape();
        polyhedron(spoints,sfaces);
}

// ruler(10);

// functions for the construction of polyhedra
// chris wallace
// see http://kitwallace.tumblr.com/tagged/polyhedra for info


//  functions for creating the matrices for transforming a single point

function m_translate(v) = [ [1, 0, 0, 0],
                            [0, 1, 0, 0],
                            [0, 0, 1, 0],
                            [v.x, v.y, v.z, 1  ] ];

function m_rotate(v) =  [ [1,  0,         0,        0],
                          [0,  cos(v.x),  sin(v.x), 0],
                          [0, -sin(v.x),  cos(v.x), 0],
                          [0,  0,         0,        1] ]
                      * [ [ cos(v.y), 0,  -sin(v.y), 0],
                          [0,         1,  0,        0],
                          [ sin(v.y), 0,  cos(v.y), 0],
                          [0,         0,  0,        1] ]
                      * [ [ cos(v.z),  sin(v.z), 0, 0],
                          [-sin(v.z),  cos(v.z), 0, 0],
                          [ 0,         0,        1, 0],
                          [ 0,         0,        0, 1] ];

function vec3(v) = [v.x, v.y, v.z];
function transform(v, m)  = vec3([v.x, v.y, v.z, 1] * m);

function matrix_to(p0, p) =
                       m_rotate([0, atan2(sqrt(pow(p[0], 2) + pow(p[1], 2)), p[2]), 0])
                     * m_rotate([0, 0, atan2(p[1], p[0])])
                     * m_translate(p0);

function matrix_from(p0, p) =
                      m_translate(-p0)
                      * m_rotate([0, 0, -atan2(p[1], p[0])])
                      * m_rotate([0, -atan2(sqrt(pow(p[0], 2) + pow(p[1], 2)), p[2]), 0]);

function transform_points(list, matrix, i = 0) =
    i < len(list)
       ? concat([ transform(list[i], matrix) ], transform_points(list, matrix, i + 1))
       : [];


//  convert from point indexes to point coordinates

function as_points(indexes,points,i=0) =
     i < len(indexes)
        ?  concat([points[indexes[i]]], as_points(indexes,points,i+1))
        : [];

//  basic vector functions
function normal_r(face) =
     cross(face[1]-face[0],face[2]-face[0]);

function normal(face) =
     - normal_r(face) / norm(normal_r(face));

function centre(points) =
      vsum(points) / len(points);

// sum a list of vectors
function vsum(points,i=0) =
      i < len(points)
        ?  (points[i] + vsum(points,i+1))
        :  [0,0,0];

function ssum(list,i=0) =
      i < len(list)
        ?  (list[i] + ssum(list,i+1))
        :  0;


// add a vector to a list of vectors
function vadd(points,v,i=0) =
      i < len(points)
        ?  concat([points[i] + v], vadd(points,v,i+1))
        :  [];

function reverse_r(v,n) =
      n == 0
        ? [v[0]]
        : concat([v[n]],reverse_r(v,n-1));

function reverse(v) = reverse_r(v, len(v)-1);

function sum_norm(points,i=0) =
    i < len(points)
       ?  norm(points[i]) + sum_norm(points,i+1)
       : 0 ;

function average_radius(points) =
       sum_norm(points) / len(points);


// select one dimension of a list of vectors
function slice(v,k,i=0) =
   i <len(v)
      ?  concat([v[i][k]], slice(v,k,i+1))
      : [];

function max(v, max=-9999999999999999,i=0) =
     i < len(v)
        ?  v[i] > max
            ?  max(v, v[i], i+1 )
            :  max(v, max, i+1 )
        : max;

function min(v, min=9999999999999999,i=0) =
     i < len(v)
        ?  v[i] < min
            ?  min(v, v[i], i+1 )
            :  min(v, min, i+1 )
        : min;

function project(pts,i=0) =
     i < len(pts)
        ? concat([[pts[i][0],pts[i][1]]], project(pts,i+1))
        : [];

function contains(n, list, i=0) =
     i < len(list)
        ?  n == list[i]
           ?  true
           :  contains(n,list,i+1)
        : false;

// normalize the points to have origin at 0,0,0
function centre_points(points) =
     vadd(points, - centre(points));

//scale to average radius = radius
function normalize(points,radius) =
    points * radius /average_radius(points);

function select_nsided_faces(faces,nsides,i=0) =
  len(nsides) == 0
     ?  faces
     :  i < len(faces)
         ?  contains(len(faces[i]), nsides)
             ? concat([faces[i]],  select_nsided_faces(faces,nsides,i+1))
             : select_nsided_faces(faces,nsides,i+1)
         : [];

function longest_edge(face,max=-1,i=0) =
       i < len(face)
          ?  norm(face[i] - face[(i+1)% len(face)]) > max
             ?  longest_edge(face, norm(face[i] - face[(i+1)% len(face)]),i+1)
             :  longest_edge(face, max,i+1)
          : max ;

function point_edges(point,edges,i=0) =
    i < len(edges)
       ? point == edges[i][0] || point == edges[i][1]
         ? concat([edges[i]], point_edges(point,edges,i+1))
         : point_edges(point,edges,i+1)
       : [];

function select_nedged_points(points,edges,nedges,i=0) =
     i < len(points)
         ?  len(point_edges(i,edges)) == nedges
             ? concat([i],  select_nedged_points(points,edges,nedges,i+1))
             : select_nedged_points(points,edges,nedges,i+1)
         : [];

function triangle(a,b) = norm(cross(a,b))/2;

function face_area_centre(face,centre,i=0) =
    i < len(face)
       ?  triangle(
                face[i] - centre,
                face[(i+1) % len(face)] - centre)
          + face_area_centre(face,centre,i+1)
       : 0 ;

function face_area(face) = face_area_centre(face,centre(face));

function face_areas(faces,points,i=0) =
   i < len(faces)
      ? concat([[i,  face_area(as_points(faces[i],points))]] ,
               face_areas(faces,points,i+1))
      : [] ;

function max_area(areas, max=[-1,-1], i=0) =
   i <len(areas)
      ? areas[i][1] > max[1]
         ?  max_area(areas,areas[i],i+1)
         :  max_area(areas,max,i+1)
      : max;


function bbox(v) = [
   [min(slice(spoints,0)), max(slice(spoints,0))],
   [min(slice(spoints,1)), max(slice(spoints,1))],
   [min(slice(spoints,2)), max(slice(spoints,2))]
];

// check that all faces have a lhs orientation
function cosine_between(u, v) =(u * v) / (norm(u) * norm(v));

function lhs_faces(faces,points,i=0) =
     i < len(faces)
        ?  cosine_between(normal(as_points(faces[i],points)),
                         centre(as_points(faces[i],points))) < 0
            ?  concat([reverse(faces[i])],lhs_faces(faces,points,i+1))
            :  concat([faces[i]],lhs_faces(faces,points,i+1))
        : [] ;


function fs(p) = f(p[0],p[1],p[2]);

function modulate_point(p) =
    spherical_to_xyz(fs(xyz_to_spherical(p)));

function modulate_points(points,i=0) =
   i < len(points)
      ? concat([modulate_point(points[i])],modulate_points(points,i+1))
      : [];

function xyz_to_spherical(p) =
    [ norm(p), acos(p.z/ norm(p)), atan2(p.x,p.y)] ;

function spherical_to_xyz_full(r,theta,phi) =
    [ r * sin(theta) * cos(phi),
      r * sin(theta) * sin(phi),
      r * cos(theta)];

function spherical_to_xyz(s) =
     spherical_to_xyz_full(s[0],s[1],s[2]);

function select_large_faces(faces,points, min,i=0) =
  i < len(faces)
     ?  face_area(as_points(faces[i],points)) > min
       ? concat([faces[i]],  select_large_faces(faces,points,min,i+1))
       :select_large_faces(faces,points,min,i+1)
     : [];

function lower(char) =
    contains(char,"abcdefghijklmnopqrstuvwxyz") ;

function char_layer(char) =
    lower(char)
         ? str(char,"_")
         : char;

module write_char(font,char) {
  linear_extrude(height=1,convexity=10)
      import(file=str("write/",font,".dxf"),layer=char_layer(char));
}

module write_centred_char(font,char) {
  linear_extrude(height=1,convexity=10)
      translate([-2.5,-4,0])
          import(file=str("write/",font,".dxf"),layer=char_layer(char));
}

module engrave_face_word(faces,points,word,font,ratio,thickness) {
  for (i=[0:len(faces) - 1]) {
    if (i <len(word)) {
      f = as_points(faces[i], points);
      n = normal(f); c = centre(f);
      s = longest_edge(f) / 20* ratio;
        orient_to(c,n)
          translate([0,0,-thickness+eps])
            scale([s,s,thickness])
              write_centred_char(font,word[i]);
    }
  }
}

module orient_to(centre, normal) {
    translate(centre)
    rotate([0, 0, atan2(normal[1], normal[0])]) //rotation
    rotate([0, atan2(sqrt(pow(normal[0], 2)+pow(normal[1], 2)),normal[2]), 0])
    children();
}

module orient_from(centre, normal) {
    rotate([0, -atan2(sqrt(pow(normal[0], 2)+pow(normal[1], 2)),normal[2]), 0])
    rotate([0, 0, -atan2(normal[1], normal[0])]) //rotation
    translate(-centre)
    children();
}

module place_on_largest_face(faces,points) {
    largest = max_area(face_areas(faces,points));
    lpoints = as_points(faces[largest[0]],points);
    n = normal(lpoints); c = centre(lpoints);
    orient_from(c,-n)
    children();
}

module make_edge(edge, points, r) {
    p0 = points[edge[0]]; p1 = points[edge[1]];
    v = p1 - p0;
    orient_to(p0,v)
      cylinder(r=r, h=norm(v));
}

module make_edges(points, edges, r) {
    for (i =[0:len(edges)-1])
      make_edge(edges[i],points, r);
}

module make_vertices(points,r) {
    for (i = [0:len(points)-1])
      translate(points[i]) sphere(r);
}

module face_prism (face,prism_base_ratio,prism_scale,prism_height_ratio) {
    n = normal(face); c= centre(face);
    m = matrix_from(c,n);
    tpts =  prism_base_ratio * transform_points(face,m);
    max_length = longest_edge(face);
    xy = project(tpts);
      linear_extrude(height=prism_height_ratio * max_length, scale=prism_scale)
          polygon(points=xy);
}

module face_prisms_in(faces,points,prism_base_ratio,prism_scale,prism_height_ratio) {
    for (i=[0:len(faces) - 1]) {
       f = as_points(faces[i],points);
       n = normal(f); c = centre(f);
       orient_to(c,n)
          translate([0,0,eps])
               mirror() rotate([0,180,0])
                   face_prism(f,prism_base_ratio,prism_scale,prism_height_ratio);
    }
}

module face_prisms_out(faces,points,prism_base_ratio,prism_scale,prism_height_ratio) {
    for (i=[0:len(faces) - 1]) {
       f = as_points(faces[i],points);
       n = normal(f); c = centre(f);
       orient_to(c,n)
          translate([0,0,-eps])
               face_prism(f,prism_base_ratio,prism_scale,prism_height_ratio);
    }
}

module face_prisms_through(faces,points,prism_base_ratio,prism_scale,prism_height_ratio) {
    for (i=[0:len(faces) - 1]) {
       f = as_points(faces[i],points);
       n = normal(f); c = centre(f);
       orient_to(c,n)
          translate([0,0,prism_height_ratio*longest_edge(f)/2])
               mirror() rotate([0,180,0])
                   face_prism(f,prism_base_ratio,prism_scale,prism_height_ratio);
    }
}
module ruler(n) {
   for (i=[0:n-1])
       translate([(i-n/2 +0.5)* 10,0,0]) cube([9.8,5,2], center=true);
}

module ground(size=50) {
   translate([0,0,-size]) cube(2*size,center=true);
}

module cross_section(size=50) {
   translate([0,0,-size]) cube(2*size);
}

module ring(radius,thickness,height) {
   difference() {
      cylinder(h=height,r=radius);
      translate([0,0,-eps]) cylinder(h=height+2*eps,r=radius - thickness);
   }
}
